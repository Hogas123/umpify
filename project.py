#COMP 3106 Final Project
#Logan Carrell sn: 101181953
import csv
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Cursor
from cvxopt import matrix, solvers

#translate CSV ump_names files from umpirescorecard.com to an array
def buildUmpGameChart(filepath):
    with open(filepath, 'r') as reader: 
        c_read = csv.reader(reader)
        arr = []
        skip = 0#skip header line
        for i in c_read:
            if skip == 1:
                arr.append(i[1:5]) #append only necessary cols
            skip = 1
    return arr

#translate CSV game_data files from baseballsavant.com to an array
def buildDataSet(filepath):
    #filter the columns to just include these key features
    #0:pitch_type, 1:date, 2:velo, 8:event, 9:description, 17:batter_hand, 18:pitcher_hand, 19:home team, 20:away team, 23:batted_type, 24:balls in count, 25:strikes in count, 29:plate cross x, 30:plate cross z, 34:outs in inning, 35:inning, 79:bat team score, 80:field team score
    #current prgrm uses: 
    #date, home team and away team to match games to umps
    #plate cross x and plate cross z as features of the data
    #event and description to determine labels of the data
    desired_cols = [0, 1, 2, 8, 9, 17, 18, 19, 20, 23, 24, 25, 29, 30, 34, 35, 79, 80] 
    with open(filepath, 'r') as reader: 
        c_read = csv.reader(reader)
        arr = []
        skip = 0 #used to skip over the header line
        for i in c_read:
            line = []
            for j in range(len(i)):
                for k in desired_cols:
                    if j == k:
                        line.append(i[j])
                        break
            if skip == 1:
                arr.append(line)
            skip = 1
    return arr

'''
class used to a single pitches data
takes inputs from the data generated by buildDataSet function (called in problemSet as game_data_r)

'''
class pitchData:
    
    def __init__(self, pitch_type, date, velo, event, description, batter_hand, pitcher_hand, home, away, batted_type, balls, strikes, p_x, p_z, outs, inning, b_score, f_score):
        #set defaults for derived vals
        self.ump = ''
        self.result = 0
        self.position = []

        #set simple passes
        self.pitch_type = pitch_type
        self.date = date
        self.batter_hand = batter_hand
        self.pitcher_hand = pitcher_hand
        self.home = home
        self.away = away
        self.balls = balls
        self.strikes = strikes
        self.outs = outs
        self.inning = inning
        self.b_score = b_score
        self.f_score = f_score
        self.batted_type = batted_type
        #set velo as float
        if velo == '': self.velo = 0.0
        else: self.velo = float(velo)
        #set position as float list
        if p_x == '': p_x = 0
        if p_z == '': p_z = 0
        self.position = [float(p_x), float(p_z)]

        #set score of the pitch 
        #scores used fully in training and testing method 0, otherwise only classifications (-1 for ball, 1 for called strike) all other pitches ignored
        #pitches have an event if they are the final pitch of the at bat
        if event != "":
           if event == "walk":
              self.result = -1 #ball must be called for walk
           elif event == "hit_by_pitch":
              self.result = 0
           elif event == "home_run":
              self.result = 0
           elif event == "single":
              self.result = 0
           elif event == "double":
              self.result = 0
           elif event == "triple":
              self.result = 0
           #differentiate between called and swinging strikeout 
           elif event == "strikeout":
                if description == "called_strike":
                    self.result == 1
                else:
                    self.result == 0
           #encompasses all other "out events"
           else:
              self.result = 0
        #handling non final pitches of at bats
        else:
           if description == "ball" or description == "blocked_ball":
              self.result = -1
           elif description == "called_strike":
              self.result = 1
           elif description == "swinging_strike":
              self.result = 0
           elif event == "foul":
              self.result = 0
           else:
              self.result = 0

    #set the ump of a pitch by searching the data produced by BuildGameChart (called in problemSet as ump_data_r)
    def set_ump(self, ump_data_r):
        for i in ump_data_r:
            if self.date == i[0] and self.home == i[2] and self.away == i[3]:
               self.ump = i[1]

    #simple text out for the pitch
    def show_pitch(self):
        print(self.result  + " " + str(self.position[0]) + "," + str(self.position[1]) )

'''
class used to store a set of pitch data elements and generate an input matrix and label vector for that set
takes a list of string inbputs representing the time periods to be used in the form MMDDMMDDYY
existing data: 
    april 24-29, 2024 
    may 8-13, 2024
    june 8-13, 2024
    july 1-4, 2024
    august 1-5, 2024
    august 24-29, 2023
    september 12-17, 2023
'''
class problemSet:
    def __init__(self, set):
        self.game_data = []
        ump_data_r = []
        game_data_r= []
        for i in set:
            ump_data_r.extend(buildUmpGameChart("S:\SchoolFiles\Fall24/3106\Project/data/" + i + "/ump_names.csv"))
            game_data_r.extend(buildDataSet("S:\SchoolFiles\Fall24/3106\Project/data/" + i + "/game_data.csv"))
        #set the game data array by translating each produced member of game_data_r to pitchData and then setting its ump
        for i in game_data_r:
            self.game_data.append(pitchData(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15], i[16], i[17]))
        for i in self.game_data:
            i.set_ump(ump_data_r)

    #display the umpires that are sampled in the set and the number of times they are sampled
    #type determines if 0: all pitches or 1: only balls and called strikes
    def showSampledUmps(self, type):
        out = []
        if type == 0:
            for i in self.game_data:
                if out == []:
                    out.append([i.ump, 1])
                else:
                    found = 0
                    for j in out:
                        if j[0] == i.ump:
                            j[1]+=1
                            found = 1
                    if found == 0:
                        out.append([i.ump, 1])
        else:
            for i in self.game_data:
                if i.result == 1 or i.result == -1:
                    if out == []:
                        out.append([i.ump, 1])
                else:
                    found = 0
                    for j in out:
                        if j[0] == i.ump:
                            j[1]+=1
                            found = 1
                    if found == 0:
                        out.append([i.ump, 1])
        #sort the result by number of apperances
        def sfunc(val):
            return val[1]
        out.sort(key=sfunc, reverse=True)
        return out

    #generate the actual input matrix X and label vector y for a specific umpire using type 0: all pitches or type:1 only balls and called strikes
    #matrix X is 2 x n, where n is max_samp or the number of available samples if there are fewer than max_samp available samples
    #vec y is 1 by n
    def genDataSet(self, ump, type, max_samp):
        out = []
        out_X = []
        out_y = []
        if type == 0:
            for i in self.game_data:
                if len(out) < max_samp:
                    if ump == "all":
                        out.append(i)
                    elif ump == i.ump:
                        out.append(i)
            
            for i in out:
                out_X.append(i.position)
                out_y.append(i.result)
        #the and in the if statement enforces only balls and called strikes as they are the only pitches given scores 1 and -1
        else:
            for i in self.game_data:
                if len(out) < max_samp:
                    if ump == "all" and (i.result == 1  or i.result == -1) :
                        out.append(i)
                    elif ump == i.ump and (i.result == 1  or i.result == -1):
                        out.append(i)
            for i in out:

                out_X.append(i.position)
                out_y.append(i.result)
        
        #translate to np arrays for ease of use with CVXOPT
        out_X = np.array(out_X)
        out_y = np.array(out_y)

        return out_X, out_y

      
    
'''
Class used to run the kernelized SVM ML model
    april 24-29, 2024 
    may 8-13, 2024
    june 8-13, 2024
    july 1-4, 2024
    august 1-5, 2024
    august 24-29, 2023
    september 12-17, 2023
'''
class umpify:
    def __init__(self):
        #initialize training dataset using all available datasets except september 2023, initialize september 2023 as the test dataset
        self.train_data = problemSet(["0424042924", "0508051324", "0608061324", "0701070424", "0801080524", "0824082923"])
        self.test_data = problemSet(["0912091723"])
       
    #Train_type 0: considers all pitches scoring non called pitches as 0
    #Train_type 1: considers only "called" pitches (called strike, ball, walk, swinging strikeout)
    #test type 0: uses all pitches from the test set
    #test type 1: uses  only "called" pitches from the test set
    def train_test(self, ump="all", tr_s=500, ts_s =100, train_type=1, test_type = 1):
        #generate train and test data from the initialized datasets using the given params
        self.train_set = self.train_data.genDataSet(ump, train_type, tr_s)
        self.test_set = self.test_data.genDataSet(ump, test_type, ts_s)

        #Perform model training and get all required calculated values for prediction (alphas, support_alphas, support_vectors, support_labels and bias)
        self.alphas = self.train_kern_svm(self.train_set[0], self.train_set[1], self.rbfKernel)
        self.s_alphas, self.s_vecs, self.s_labels, self.b = self.getModelParams(self.train_set[0], self.train_set[1], self.alphas, self.rbfKernel)

        y_pred = np.sign(self.predict(self.test_set[0], self.s_alphas, self.s_vecs, self.s_labels, self.b, self.rbfKernel))
        accuracy = np.mean(y_pred == self.test_set[1])
        print("Test Accuracy:", accuracy)

    #using RBF (radial basis function) kernel to allow for non-linear class seperation
    #essentially uses the density of points to determine classes, ie 'closer' points are more likely to be in the same class
    def rbfKernel(self, x1, x2, gamma=0.5):
        return np.exp(-gamma * np.linalg.norm(x1 -x2) **2)

    #determine the k matrix of X using the given rbf kernel function above
    #this determines the value using k_func for every combo of n,n
    def getKernMatrix(self, X, k_func, gamma=0.5):
        n, d = X.shape

        k = np.zeros((n,n))
        for i in range(n):
            for j in range(n):
                k[i,j] = k_func(X[i], X[j])
        return k

    #train SVM model to extract alphas using  CVXOPT
    #https://cvxopt.org/userguide/coneprog.html#quadratic-cone-programs
    def train_kern_svm(self, X, y, k_func, C=1.0, gamma=0.5):

        n, d = X.shape
        y = y.astype(float) #must make y a float explicity for np to work properly
        k = self.getKernMatrix(X, k_func, gamma=0.5)

        #formulate QP problem
        #solves: min (1/2)xTPx + qTx, such that Gx <= h and Ax = b

        P = matrix(np.outer(y,y) * k) #quadratic term
        q = matrix(-np.ones(n)) #linear term
        G = matrix(np.vstack((-np.eye(n), np.eye(n)))) #box contraint, ensures that alphas are between 0 and C
        h = matrix(np.hstack((np.zeros(n), np.ones(n) * C))) #define the bounds of box
        A = matrix(y.reshape(1,-1)) # row vec for y used to ensure the sum of all support vectors with their labels is 0.
        b = matrix(0.0) #bias term for centering on data

        solvers.options['show_progress'] = False
        sol = solvers.qp(P, q, G, h, A, b)
        alphas = np.array(sol['x']).flatten() #get answers as a flat array
        return alphas

    #Extract params from alphas to use for predictions
    def getModelParams(self, X, y, alphas, k_func, gamma=0.5):

        s_indices = np.where(alphas > 0.00001)[0]
        #get all support values using index from above
        s_alphas = alphas[s_indices]
        s_vecs = X[s_indices]
        s_labels = y[s_indices]

        #calculate bias using b = y[i] - sum j(s_alpha[j] * s_label[j] *K(xixj))
        b_sum = 0
        for i in s_indices:
            t_sum = 0
            for j in range(len(s_alphas)):
                t_sum += (s_alphas[j] * s_labels[j] * k_func(X[i], s_vecs[j], gamma=0.5))
        
            b_sum += y[i] - t_sum
        b = b_sum / len(s_indices)
        return np.array(s_alphas), np.array(s_vecs), np.array(s_labels), b

    #Computes prediction vector yhat of shape n by 1 from X of shape n by 2, using the trained SVM model and its extracted params
    def predict(self, X, s_alphas, s_vecs, s_labels, b, k_func, gamma = 0.5):
        predictions = []
        for x in X:
            decision = 0
            #over all support vecs, compute the decision contribution using s_alpha[i] * s_label[i] * kernel val at xi,xi. Then sum all decision contributions to get the decision value for one predicted point
            for i in range(len(s_alphas)):
                a = s_alphas[i]
                l = s_labels[i]
                sv = s_vecs[i]

                decision += a * l * k_func(x, sv, gamma=0.5)
            decision += b
            predictions.append(decision)
        return np.array(predictions)

    #disp type 0: displays just the countour between classes (balls and strikes)
    #disp type 1: uses the decision value to create a leveled heat map to illustrate confidence in predictions (lvls controls num of heat levels)
    #density controls resolution of the mesh used to draw the contours higher density drastically increases runtime
    def int_map(self, t_points=0, s_zone=1, density=100, disp_type=0, lvls=10):
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.set_title('Click For Placement')
        ax.set_xlabel("Horizontal Location @ plate")
        ax.set_ylabel("Vertical Location @ plate")

    #set the dimensions of the plot
        ax.set_xlim(-3.0, 3.0)  
        ax.set_ylim(-1.0, 5.0)  

    #plot training points if desired    
        if t_points:
            ax.scatter(self.train_set[0][self.train_set[1] == 1, 0], self.train_set[0][self.train_set[1] == 1, 1], color='b', label='Strike', edgecolors='k')
            ax.scatter(self.train_set[0][self.train_set[1] == -1, 0], self.train_set[0][self.train_set[1] == -1, 1], color='r', label='Ball', edgecolors='k')
    
    #add "ideal" strike zone overlay
        if s_zone:
            dim = [2.0,2.2]  
            center = [0.0, 2.5] 
        #draw zone
            strike_zone = plt.Rectangle( (center[0] - dim[0] / 2, center[1] - dim[1] / 2), dim[0], dim[1], linewidth=5, edgecolor='black', facecolor='lightgray', alpha=0.7)
            ax.add_patch(strike_zone)

        x_min = self.train_set[0][:, 0].min() - 0.1
        y_min = self.train_set[0][:, 1].min() - 0.1
        x_max = self.train_set[0][:, 0].max() + 0.1
        y_max = self.train_set[0][:, 1].max() + 0.1
        xx, yy = np.meshgrid(np.linspace(x_min, x_max, density),np.linspace(y_min, y_max, density)) #sets grid of all possible points within training set
        #Flatten the grid into a 2D array of points
        grid_points = np.c_[xx.ravel(), yy.ravel()]
        # Plot the decision boundary: areas where the prediction is -1 or 1
        if disp_type == 0:
            # Predict the class of each grid point
            Z = np.sign(self.predict(grid_points, self.s_alphas, self.s_vecs, self.s_labels, self.b, self.rbfKernel, gamma=0.5))
            Z = Z.reshape(xx.shape)
            ax.contourf(xx, yy, Z, alpha=0.5, levels=[-1, 0, 1], colors=['red', 'blue'], linestyles=['--', '--'])
        #plot a cool warm map with lvls levels using the decision values as provided using mode 1
        else:
            # Predict the class of each grid point, really using decision value this time
            Z = self.predict(grid_points, self.s_alphas, self.s_vecs, self.s_labels, self.b, self.rbfKernel, gamma=0.5)
            Z = Z.reshape(xx.shape)
            ax.contourf(xx, yy, Z, levels=lvls, cmap='coolwarm', alpha=0.8)
        #Add cursor 
        cursor = Cursor(ax, useblit=True, color='red', linewidth=1)
    
        def on_click(event):
            if event.inaxes != ax:  # Check if the click is within the axes bounds
                return
            # Get the position of the click
            x_click, y_click = event.xdata, event.ydata
            point = np.array([[x_click, y_click]])
             # Predict the class of the point
            pred = self.predict(point, self.s_alphas, self.s_vecs, self.s_labels, self.b, self.rbfKernel, gamma=0.5)
         # Plot the point
            if pred >= 0.2:
                 c = "r"
            elif pred <= -0.2:
                c = "b"
            else:
            #allows for white coloring of very uncertain (-0.2 - 0.2) placed pitches
                c = "w"
            #draw the pitch and tell the user about the result in the terminal
            ax.scatter(x_click, y_click, color= c, s=80, edgecolors='k', label="Pitch")
            plt.draw()
            print(f"Pitch at ({x_click:.2f}, {y_click:.2f}) is classified as {'Strike' if pred > 0 else 'Ball'}.")
        # Connect the click event to the on_click function
        fig.canvas.mpl_connect('button_press_event', on_click)
        # Show the plot
        plt.legend()
        plt.grid(True)
        plt.show()


test1 = umpify()

#train_test takes (ump_name, max_samp_tr, max_samp_test, tr_type, test_type)
#int_map takes (show_training_points, show_SZ, density, display_type, levels (only for type 1) )
#Good Ump examples:
    #Dan Merzel, 755, 457
    #Clint Vondrak, 882, 314
    #Junior Valentine, 682, 404
    #Sean Barber, 922, 278
    #Tripp Gibson, 909, 287
    #Jim Wolf, 980, 156
    #Derek Thomas, 1075, 256
test1.train_test("Derek Thomas", 700, 80, 1, 1)
test1.int_map(1, 1, 200, 1, 10)

